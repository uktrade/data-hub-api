import uuid

from django.conf import settings
from django.core.validators import MaxValueValidator, MinValueValidator
from django.db import models, transaction
from django.utils.crypto import get_random_string
from django.utils.timezone import now

from datahub.company.models import Advisor, Company, Contact
from datahub.core.models import (
    BaseConstantModel, BaseModel, BaseOrderedConstantModel, DisableableModel
)

from datahub.metadata.models import Country, Sector, Team
from datahub.omis.core.utils import generate_reference
from datahub.omis.quote.models import Quote

from . import validators
from .constants import DEFAULT_HOURLY_RATE, OrderStatus


class ServiceType(BaseOrderedConstantModel, DisableableModel):
    """
    Order service type.
    E.g. 'Validated contacts', 'Event', 'Market Research'
    """


class HourlyRate(BaseConstantModel):
    """
    Values for the hourly rates used to calculate order pricing and for the
    current VAT to apply.
    """

    created_on = models.DateTimeField(auto_now_add=True)
    modified_on = models.DateTimeField(auto_now=True)

    rate_value = models.PositiveIntegerField(
        help_text='Rate in pence. E.g. 1 pound should be stored as 100 (100 pence).'
    )
    vat_value = models.DecimalField(
        max_digits=5, decimal_places=2,
        help_text='VAT to apply as percentage value (0.00 to 100.00).',
        validators=[
            MinValueValidator(0),
            MaxValueValidator(100),
        ]
    )

    class Meta(BaseConstantModel.Meta):  # noqa: D101
        db_table = 'omis-order_hourlyrate'


class Order(BaseModel):
    """
    Details regarding an OMIS Order.

    States:

        Draft (OrderStatus.draft)
            An order is created by one or more DIT advisers to holds the details
            of the service offered to a specific contact (the client).
            An order can stay in draft for as long as needed if the details have not
            been defined yet.
        Quote sent / awaiting acceptance (OrderStatus.quote_awaiting_acceptance)
            When the details have been defined and the related information filled in,
            a quote can be generated by the adviser.
            After this point, the order becomes readonly and the client is asked to approve it.
            The DIT adviser can still reopen the order and cancel the quote.
            A new quote would have to be generated, sent and accepted by the client in this case.
        Quote accepted (OrderStatus.quote_accepted)
            After accepting the quote, the client receives an invoice and is asked to pay.
            At this point but before paying, the order can still be reopened and
            the quote cancelled.
            A new quote would have to be generated, sent and accepted by the client in this case.
        Paid (OrderStatus.paid)
            The contact pays for the order. After this point, the order cannot be reopened.
        Complete (OrderStatus.complete)
            The DIT adviser delivers the service.
        Cancelled (OrderStatus.cancelled)
            The order has been cancelled.
    """

    id = models.UUIDField(primary_key=True, default=uuid.uuid4)
    reference = models.CharField(max_length=100)

    status = models.CharField(
        max_length=100,
        choices=OrderStatus,
        default=OrderStatus.draft
    )

    company = models.ForeignKey(
        Company,
        related_name="%(class)ss",  # noqa: Q000
        on_delete=models.PROTECT,
    )
    contact = models.ForeignKey(
        Contact,
        related_name="%(class)ss",  # noqa: Q000
        on_delete=models.PROTECT
    )

    primary_market = models.ForeignKey(
        Country,
        related_name="%(class)ss",  # noqa: Q000
        null=True,
        on_delete=models.SET_NULL
    )
    sector = models.ForeignKey(
        Sector,
        related_name='+',
        null=True, blank=True,
        on_delete=models.SET_NULL
    )

    service_types = models.ManyToManyField(
        ServiceType,
        related_name="%(class)ss",  # noqa: Q000
        blank=True
    )
    description = models.TextField(
        blank=True,
        help_text='Description of the work needed.'
    )
    contacts_not_to_approach = models.TextField(
        blank=True,
        help_text='Are there contacts that DIT should not approach?'
    )

    delivery_date = models.DateField(blank=True, null=True)

    contact_email = models.EmailField(blank=True)
    contact_phone = models.CharField(max_length=254, blank=True)

    quote = models.OneToOneField(
        Quote,
        null=True, blank=True,
        on_delete=models.SET_NULL
    )

    po_number = models.CharField(max_length=100, blank=True)

    hourly_rate = models.ForeignKey(
        HourlyRate,
        related_name="%(class)ss",  # noqa: Q000
        on_delete=models.PROTECT,
        default=DEFAULT_HOURLY_RATE
    )
    discount_value = models.PositiveIntegerField(default=0)
    discount_label = models.CharField(max_length=100, blank=True)

    # legacy fields, only meant to be used in readonly mode as reference
    product_info = models.TextField(
        blank=True, editable=False,
        help_text='Legacy field. What is the product?'
    )
    further_info = models.TextField(
        blank=True, editable=False,
        help_text='Legacy field. Further information.'
    )
    existing_agents = models.TextField(
        blank=True, editable=False,
        help_text='Legacy field. Details of any existing agents.'
    )
    permission_to_approach_contacts = models.TextField(
        blank=True, editable=False,
        help_text='Legacy field. Can DIT speak to the contacts?'
    )

    def __str__(self):
        """Human-readable representation"""
        return self.reference

    @classmethod
    def generate_reference(cls):
        """
        :returns: a random unused reference of form:
            <(3) letters><(3) numbers>/<year> e.g. GEA962/16
        :raises RuntimeError: if no reference can be generated.
        """
        def gen():
            year_suffix = now().strftime('%y')
            return '{letters}{numbers}/{year}'.format(
                letters=get_random_string(length=3, allowed_chars='ACEFHJKMNPRTUVWXY'),
                numbers=get_random_string(length=3, allowed_chars='123456789'),
                year=year_suffix
            )

        return generate_reference(model=cls, gen=gen)

    def save(self, *args, **kwargs):
        """
        Like the django save but it creates a reference if it doesn't exist.
        """
        if not self.reference:
            self.reference = self.generate_reference()
        return super().save(*args, **kwargs)

    def get_datahub_frontend_url(self):
        """Return the url to the Data Hub frontend order page."""
        return f'{settings.DATAHUB_FRONTEND_BASE_URL}/omis/{self.pk}'

    @transaction.atomic
    def generate_quote(self, by, commit=True):
        """
        Generate a new quote and assign it to the current order.
        The status of the order changes to "Quote awaiting acceptance".

        :returns: a quote for this order

        :param by: who made the action
        :param commit: if False, the changes will not be saved. Useful for previewing a quote

        :raises rest_framework.exceptions.ValidationError: in case of validation error
        :raises datahub.omis.core.exceptions.Conflict: in case of errors with the state of the
            current order
        :raises RuntimeError: after trying max_retries times without being able to generate a
            valid value for the quote reference
        """
        for validator in [
            validators.OrderDetailsFilledInValidator(),
            validators.NoOtherActiveQuoteExistsValidator(),
            validators.OrderInStatusValidator(
                allowed_statuses=(OrderStatus.draft,)
            )
        ]:
            validator.set_instance(self)
            validator()

        self.quote = Quote.objects.create_from_order(order=self, by=by, commit=commit)
        self.status = OrderStatus.quote_awaiting_acceptance

        if commit:
            self.save()

        return self.quote

    @transaction.atomic
    def reopen(self, by):
        """
        Cancel quote and reopen order if possible.
        The status of the order changes back to "Draft".
        """
        for validator in [
            validators.OrderInStatusValidator(
                allowed_statuses=(
                    OrderStatus.draft,
                    OrderStatus.quote_awaiting_acceptance,
                    OrderStatus.quote_accepted,
                )
            )
        ]:
            validator.set_instance(self)
            validator()

        if self.quote:
            self.quote.cancel(by)

        self.status = OrderStatus.draft
        self.save()


class OrderSubscriber(BaseModel):
    """
    A subscribed adviser receives notifications when new changes happen to an Order.
    """

    id = models.UUIDField(primary_key=True, default=uuid.uuid4)
    order = models.ForeignKey(
        Order, on_delete=models.CASCADE, related_name='subscribers'
    )
    adviser = models.ForeignKey(
        Advisor, on_delete=models.CASCADE, related_name='+'
    )

    def __str__(self):
        """Human-readable representation"""
        return f'{self.order} â€“ {self.adviser}'

    class Meta:  # noqa: D101
        ordering = ['created_on']
        unique_together = (
            ('order', 'adviser'),
        )


class OrderAssignee(BaseModel):
    """
    An adviser assigned to an Order and responsible for deliverying the final report(s).
    """

    id = models.UUIDField(primary_key=True, default=uuid.uuid4)

    order = models.ForeignKey(Order, on_delete=models.CASCADE, related_name='assignees')
    adviser = models.ForeignKey(Advisor, on_delete=models.PROTECT, related_name='+')
    team = models.ForeignKey(Team, blank=True, null=True, on_delete=models.SET_NULL)
    country = models.ForeignKey(Country, blank=True, null=True, on_delete=models.SET_NULL)

    estimated_time = models.IntegerField(default=0, help_text='Estimated time in minutes.')
    is_lead = models.BooleanField(default=False)

    class Meta:  # noqa: D101
        ordering = ['created_on']
        unique_together = (
            ('order', 'adviser'),
        )

    def __init__(self, *args, **kwargs):
        """
        Keep the original adviser value so that we can see if it changes when saving.
        """
        super().__init__(*args, **kwargs)
        self.__adviser = self.adviser

    def __str__(self):
        """Human-readable representation"""
        return (
            f'{"" if self.is_lead else "Not "}Lead Assignee '
            f'{self.adviser} for order {self.order}'
        )

    def save(self, *args, **kwargs):
        """
        Makes sure that the adviser cannot be changed after creation.
        When creating a new instance, it also denormalises `team` and `country` for
        future-proofing reasons, that is, if an adviser moves to another team in the future
        we don't want to change history.
        """
        if not self._state.adding and self.__adviser != self.adviser:
            raise ValueError("Updating the value of adviser isn't allowed.")

        if self._state.adding:
            self.team = self.adviser.dit_team
            if self.team:
                self.country = self.team.country

        super().save(*args, **kwargs)

        self.__adviser = self.adviser
